// generated by DeepSeek
// 2025.5.30
// Prompt: 实现一个新的函数，对F(2, 2, 10)的矩阵求行列式，其他条件不变。按照前面代码的风格生成。
// 由于2*2行列式的阶数低，希望只输出35个非零项。

#include "mex.h"
#include <vector>
#include <map>
#include <algorithm>
#include <iostream>
#include <cmath>
using namespace std;

struct Triple {
    int a, b, c;
    Triple() : a(0), b(0), c(0) {}
    Triple(int a_, int b_, int c_) : a(a_), b(b_), c(c_) {}
    bool operator<(const Triple &other) const {
        if (a != other.a) return a < other.a;
        if (b != other.b) return b < other.b;
        return c < other.c;
    }
    bool operator==(const Triple &other) const {
        return (a == other.a) && (b == other.b) && (c == other.c);
    }
};

// 生成0-4次的35项基
vector<Triple> generate_reduced_basis() {
    vector<Triple> basis;
    // 总次数从4降到0
    for (int d = 4; d >= 0; d--) {
        // z指数从0到d
        for (int c = 0; c <= d; c++) {
            // x指数从高到低
            for (int a = d - c; a >= 0; a--) {
                int b = d - c - a;  // y指数
                basis.push_back(Triple(a, b, c));
            }
        }
    }
    return basis;
}

typedef map<Triple, double> PolyType;

PolyType poly_multiply(const PolyType &A, const PolyType &B) {
    PolyType C;
    if (A.empty() || B.empty()) return C;
    for (const auto &term1 : A) {
        for (const auto &term2 : B) {
            Triple exp1 = term1.first;
            Triple exp2 = term2.first;
            Triple exp_new(exp1.a + exp2.a, exp1.b + exp2.b, exp1.c + exp2.c);
            double coef = term1.second * term2.second;
            if (fabs(coef) > 1e-15) {
                C[exp_new] += coef;
            }
        }
    }
    return C;
}

PolyType poly_add(const PolyType &A, const PolyType &B) {
    PolyType C = A;
    for (const auto &term : B) {
        Triple exp = term.first;
        double coef = term.second;
        if (fabs(coef) > 1e-15) {
            C[exp] += coef;
            if (fabs(C[exp]) < 1e-15) {
                C.erase(exp);
            }
        }
    }
    return C;
}

PolyType poly_scale(const PolyType &A, double s) {
    PolyType C;
    if (fabs(s) < 1e-15) return C;
    for (const auto &term : A) {
        double coef = term.second * s;
        if (fabs(coef) > 1e-15) {
            C[term.first] = coef;
        }
    }
    return C;
}

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) {
    if (nrhs != 1) {
        mexErrMsgIdAndTxt("det2x2poly:nrhs", "One input required.");
    }
    if (nlhs != 1) {
        mexErrMsgIdAndTxt("det2x2poly:nlhs", "One output required.");
    }
    
    double *F_data = mxGetPr(prhs[0]);
    const mwSize *dims = mxGetDimensions(prhs[0]);
    if (dims[0] != 2 || dims[1] != 2 || dims[2] != 10) {
        mexErrMsgIdAndTxt("det2x2poly:dimension", "Input must be 2x2x10.");
    }

    // 生成35项基（0-4次）
    vector<Triple> basis = generate_reduced_basis();
    map<Triple, int> index_map;
    for (int i = 0; i < basis.size(); i++) {
        index_map[basis[i]] = i;
    }

    // 输入多项式基（10项）
    Triple basis_input[10] = {
        Triple(2,0,0), // x^2
        Triple(1,1,0), // x*y
        Triple(1,0,1), // x*z
        Triple(1,0,0), // x
        Triple(0,2,0), // y^2
        Triple(0,1,1), // y*z
        Triple(0,1,0), // y
        Triple(0,0,2), // z^2
        Triple(0,0,1), // z
        Triple(0,0,0)  // 1
    };

    // 创建多项式矩阵
    PolyType F_poly[2][2];
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            PolyType poly;
            for (int k = 0; k < 10; k++) {
                double coef = F_data[i + 2*j + 4*k];
                if (fabs(coef) > 1e-15) {
                    poly[basis_input[k]] = coef;
                }
            }
            F_poly[i][j] = poly;
        }
    }

    // 计算2x2行列式: det = F11*F22 - F12*F21
    PolyType term1 = poly_multiply(F_poly[0][0], F_poly[1][1]);
    PolyType term2 = poly_multiply(F_poly[0][1], F_poly[1][0]);
    term2 = poly_scale(term2, -1.0); // 乘以-1
    PolyType result_poly = poly_add(term1, term2);

    // 创建35维输出向量
    plhs[0] = mxCreateDoubleMatrix(35, 1, mxREAL);
    double *output = mxGetPr(plhs[0]);
    fill(output, output + 35, 0.0);
    
    // 填充输出向量
    for (const auto &term : result_poly) {
        auto it = index_map.find(term.first);
        if (it != index_map.end()) {
            int idx = it->second;
            output[idx] = term.second;
        }
        // 忽略高于4次的项（理论上不应该存在）
    }
}
