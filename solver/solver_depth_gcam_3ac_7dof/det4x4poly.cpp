// generated by DeepSeek
// 2025.5.30
// Prompt: 给定一个矩阵F，它是4*4*10的尺寸。F(i, j, :) 代表一个多项式，它的项分别为[x^2, x*y, x*z, x, y^2, y*z, y, z^2, z, 1]。
// 请用matlab mex C++实现一个函数，计算F的行列式。
// 输出为一个165维的向量，它对应的项序为graded lexicographical order

#include "mex.h"
#include <vector>
#include <map>
#include <algorithm>
#include <iostream>
#include <cmath>
using namespace std;

struct Triple {
    int a, b, c;
    Triple() : a(0), b(0), c(0) {}
    Triple(int a_, int b_, int c_) : a(a_), b(b_), c(c_) {}
    bool operator<(const Triple &other) const {
        if (a != other.a) return a < other.a;
        if (b != other.b) return b < other.b;
        return c < other.c;
    }
    bool operator==(const Triple &other) const {
        return (a == other.a) && (b == other.b) && (c == other.c);
    }
};

vector<Triple> generate_basis() {
    vector<Triple> basis;
    for (int d = 8; d >= 0; d--) {
        for (int c = 0; c <= d; c++) {
            for (int a = d - c; a >= 0; a--) {
                int b = d - c - a;
                basis.push_back(Triple(a, b, c));
            }
        }
    }
    return basis;
}

typedef map<Triple, double> PolyType;

PolyType poly_multiply(const PolyType &A, const PolyType &B) {
    PolyType C;
    if (A.empty() || B.empty()) return C;
    for (const auto &term1 : A) {
        for (const auto &term2 : B) {
            Triple exp1 = term1.first;
            Triple exp2 = term2.first;
            Triple exp_new(exp1.a + exp2.a, exp1.b + exp2.b, exp1.c + exp2.c);
            double coef = term1.second * term2.second;
            if (fabs(coef) > 1e-15) {
                C[exp_new] += coef;
            }
        }
    }
    return C;
}

PolyType poly_add(const PolyType &A, const PolyType &B) {
    PolyType C = A;
    for (const auto &term : B) {
        Triple exp = term.first;
        double coef = term.second;
        if (fabs(coef) > 1e-15) {
            C[exp] += coef;
            if (fabs(C[exp]) < 1e-15) {
                C.erase(exp);
            }
        }
    }
    return C;
}

PolyType poly_scale(const PolyType &A, double s) {
    PolyType C;
    if (fabs(s) < 1e-15) return C;
    for (const auto &term : A) {
        double coef = term.second * s;
        if (fabs(coef) > 1e-15) {
            C[term.first] = coef;
        }
    }
    return C;
}

int inversion_count(const vector<int> &p) {
    int n = p.size();
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (p[i] > p[j]) count++;
        }
    }
    return count;
}

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) {
    if (nrhs != 1) {
        mexErrMsgIdAndTxt("det4x4poly:nrhs", "One input required.");
    }
    if (nlhs != 1) {
        mexErrMsgIdAndTxt("det4x4poly:nlhs", "One output required.");
    }
    
    double *F_data = mxGetPr(prhs[0]);
    const mwSize *dims = mxGetDimensions(prhs[0]);
    if (dims[0] != 4 || dims[1] != 4 || dims[2] != 10) {
        mexErrMsgIdAndTxt("det4x4poly:dimension", "Input must be 4x4x10.");
    }

    vector<Triple> basis = generate_basis();
    map<Triple, int> index_map;
    for (int i = 0; i < basis.size(); i++) {
        index_map[basis[i]] = i;
    }

    Triple basis_input[10] = {
        Triple(2,0,0), // x^2
        Triple(1,1,0), // x*y
        Triple(1,0,1), // x*z
        Triple(1,0,0), // x
        Triple(0,2,0), // y^2
        Triple(0,1,1), // y*z
        Triple(0,1,0), // y
        Triple(0,0,2), // z^2
        Triple(0,0,1), // z
        Triple(0,0,0)
    };

    PolyType F_poly[4][4];
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            PolyType poly;
            for (int k = 0; k < 10; k++) {
                double coef = F_data[i + 4*j + 16*k];
                if (fabs(coef) > 1e-15) {
                    poly[basis_input[k]] = coef;
                }
            }
            F_poly[i][j] = poly;
        }
    }

    vector<int> perm = {0,1,2,3};
    vector<vector<int>> all_perms;
    do {
        all_perms.push_back(perm);
    } while (next_permutation(perm.begin(), perm.end()));

    PolyType result_poly;
    for (const auto &p : all_perms) {
        int inv_count = inversion_count(p);
        double sign = (inv_count % 2 == 0) ? 1.0 : -1.0;
        
        PolyType product;
        product[Triple(0,0,0)] = 1.0;
        
        for (int i = 0; i < 4; i++) {
            int j = p[i];
            product = poly_multiply(product, F_poly[i][j]);
        }
        
        product = poly_scale(product, sign);
        result_poly = poly_add(result_poly, product);
    }

    plhs[0] = mxCreateDoubleMatrix(165, 1, mxREAL);
    double *output = mxGetPr(plhs[0]);
    fill(output, output + 165, 0.0);
    
    for (const auto &term : result_poly) {
        auto it = index_map.find(term.first);
        if (it != index_map.end()) {
            int idx = it->second;
            output[idx] = term.second;
        }
    }
}